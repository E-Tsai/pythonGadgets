#!/usr/bin/env python3

# A simple method to evaluate 
# Euler Totient Function 
#from math import gcd

def gcd(a, b): 
  
    if (a == 0): 
        return b 
    return gcd(b % a, a) 

def totient(n): 
  
    result = 1
    for i in range(2, n): 
        if (gcd(i, n) == 1): 
            result+=1
    return result 

def mmi(a, m) : 
    a = a % m; 
    i = 1
    #for x in range(1, m) :
    while (i < m): 
        if ((a * i) % m == 1) : 
            return i 
        i = i + 1
    return 1


from Crypto.PublicKey import RSA
from Crypto.Util.number import long_to_bytes
p = 151431222678115056230049561799821896000894433992139105349367202106376646613993111976830459202410688325203370775820064860132386642911039825476903483164186454771308071653345726759686860864545248059853578318335428882865211647011250492094384052835111354976899006519315123664508339155948515234054380963362075845231
q = 170337135024184901777385925818701888923976205750970777789102905927789463710999893164744348194309713702360086626743658434564052800257815234433214192529415026137815255225905865529905834231900715630861068447322035870561603465758093433197569007739054651734470300164916623991469309444901250674138888934307458434763
n = p * q
output = 15845890249004603991356255724520091932799596143447042704929815476703158753100317284429130808458520775102950582058385002365898278001885857605985363517687134515323690609979156888324443180892900867684406762990745732498800044938755339940068531803087907319071931763346383660506548410297790832527458594075708970197681893354805844588844932236897125712000287809338967798545214308698853156685804703706607270535488077671069462863637199780654536747363661291956618890335283505661067090396566097515272115792250749088627482850229284409389958918205468571328067262933190825617596123280225016782367080751490897897511600946932213774948
e = 65537
eulerphi_n = n - 3 #totient(n)
d = mmi(e, eulerphi_n)
# modular multiplicative inverse 
c = pow(output, d, n)
flag = long_to_bytes(c).decode()
print(flag)